<div class="text-left blog-post-text">
  <p class="mb-4">
    The JavaScript
    <a
      href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch"
      >Fetch</a
    >
    API provides a utility to make
    <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX">AJAX</a>
    requests. This post will show how ES6 syntax can be used with Typescript and
    the Fetch API to submit an HTML form. Using the Fetch API in conjunction
    with other
    <a href="https://developer.mozilla.org/en-US/docs/Web/API">Web API's</a> a
    post request can be sent, containing
    <a
      href="https://developer.mozilla.org/en-US/docs/Web/API/FormData/Using_FormData_Objects"
      >FormData Objects</a
    >
    in the body of the request. If you would like more infomration about
    Typescript please read my post describing how to
    <a href="/npm-compile-typescript">compile TypeScript with npm</a>.
  </p>

  <!-- ad unit-->
  <%- include('../partials/ad-unit'); -%>

  <h2>HTML Form</h2>

  <p>
    First we need to create an html file, let's call it index.html, with a form
    element to capture the input values we are going to submit using JavaScript.
  </p>

  <pre class="border rounded bg-light">
    <code>
    &lt;!-- index.html --&gt;
    &lt;!DOCTYPE html&gt;
    &lt;html lang="en"&gt;
    &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Example Form&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;form id="myForm" action="myFormAction" method="post"&gt;

        &lt;!-- this input is hidden with a value already set --&gt;
        &lt;input type="hidden" id="userId" name="userId" value="3"/&gt;  

        &lt;label for="firstName"&gt;first name&lt;/label&gt;
        &lt;input type="text" id="firstName" name="firstName"/&gt;

        &lt;button type="submit"&gt;Submit&lt;/button&gt;
      &lt;/form&gt;
      &lt;script src="form.js"&gt;&lt;/script&gt;
    &lt;/body&gt;    
    &lt;/html&gt;
    </code>
  </pre>

  <p>
    Take note that the value for the form action attribute is a placeholder. In
    real usage this would be replaced with url that you would like to submit the
    form to. Just for fun, one of the inputs is <kbd>type=hidden</kbd> to show
    that we can submit hidden elements using this technique. Additionally there
    is one input to capture first name and button to submit the form using the
    HTTP post method.
  </p>

  <h2>Typescript Form Submit</h2>

  <p>
    Next we'll need to write form.ts so the TypeScript compiler can generate the
    JavaScript file, form.js, referenced in index.html. The code in form.ts will
    handle the form submit by making an AJAX request. If you haven't already now
    is a good time to read my other post
    <a href="/npm-compile-typescript">Compile Typescript with npm.</a> There you
    will find instructions on how to install and configure TypeScript to
    accomodate the usage below.
  </p>

  <p>
    <b>*NOTE*</b>: The code below assumes the endpoint we are submitting the
    form to, in the sample HTML <kbd>action="myFormAction"</kbd>, will be
    returning a response that has the
    <a
      href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type"
      >Content-Type</a
    >
    header set to
    <a href="https://www.iana.org/assignments/media-types/application/json"
      >application/json</a
    >.
  </p>

  <p>
    To begin an event listener is created to listen for all form submit events.
    Notice that the callback function is marked as an async function. Using the
    async modifier allows for the use of the await keyword when executing the
    asynchronous Fetch request.
  </p>

  <pre class="border rounded bg-light">
    <code>
      // form.ts

      // listen for any form submit event 
      document.body.addEventListener("submit", async function(event) {
            
      });      
    </code>
  </pre>

  <p>
    Inside the callback the first line of code prevents the default action from
    occuring. Without preventing the default, the browser would attempt to
    navigate to the URL of the form action attribute when the form is submitted.
  </p>

  <pre class="border rounded bg-light">
    <code>
      // form.ts

      // listen for any form submit event 
      document.body.addEventListener("submit", async function(event) {
        event.preventDefault();
      });      
    </code>
  </pre>

  <p>
    Next a variable for the form element is created and cast to an
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement"
      >HTMLFormElement</a
    >
    to allow access to the action and method properties.
  </p>

  <pre class="border rounded bg-light">
    <code>
      // form.ts

      // listen for any form submit event 
      document.body.addEventListener("submit", async function(event) {
        event.preventDefault();
        
        const form = event.target as HTMLFormElement;
      });      
    </code>
  </pre>

  <h2>Fetch API Post Form Data</h2>

  <p>
    Then the result variable is created and it is used to store the response
    sent following the Fetch request. The Fetch request returns a promise and
    must be awaited so that the result can be obtained. The URL passed into the
    Fetch method is set to the action of the form, and the options contains keys
    for method and body values. The form method, like the action, is available
    from HTMLFormElement.
  </p>

  <pre class="border rounded bg-light">
    <code>
      // listen for any form submit event 
      document.body.addEventListener("submit", async function(event) {

        event.preventDefault();

        const form = event.target as HTMLFormElement;

        // casting to any here to satisfy tsc
        // sending body as x-www-form-url-encoded
        const result = await fetch(form.action, {
          method: form.method,
          body: new URLSearchParams([...(new FormData(form) as any)])
        })        
        .then((response: Response) => response.json())
        .then(json => json)
        .catch(error => console.log(error));        
      });      
    </code>
  </pre>

  <p>
    Notice the use of
    <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax"
      >spread syntax</a
    >
    to transform the
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"
      >FormData</a
    >
    into an array of key-value pairs. This may seem redudant, but the Edge
    browser cannot iterate over FormData objects. By transforming the object
    into an array, Edge is able to successfully construct the
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"
      >URLSearchParams</a
    >
    object.
  </p>
  <p>
    Interestingly the current
    <a
      href="https://github.com/microsoft/TypeScript/blob/75301c8e2ce498359a6b33c3f9c9a6a1bd5980c0/lib/lib.dom.d.ts#L16109"
      >TypeScript definition for URLSearchParams</a
    >
    does not permit a FormData object to be passed into the constructor, however
    this is valid JavaScript. To satisfy the TypeScript compiler the FormData
    object is cast to <kbd>any</kbd>. This allows a URLSearchParams object to be
    constructed from the FormData object which itself is constructed from the
    HTMLFormElement. Since the body of the Fetch request is of the type
    URLSearchParams (hint: it looks like a ?query=string) the resulting
    Content-Type of the request body will be <kbd>x-www-form-url-encoded</kbd>.
    This allows for the server to parse it as it would a normal form submission.
  </p>

  <p>
    Now when the form in the index.html file is submitted the submit event
    listener will override the default browser behavior and submit the form
    using an AJAX request. Even without an actual endpoint to receive the
    request you should still be able to verify the code is working because the
    resulting error <kbd>Failed to fetch</kbd> will be logged to the console.
  </p>
</div>
